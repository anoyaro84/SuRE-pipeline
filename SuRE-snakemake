# vim: syntax=python expandtab
# coding: utf-8

import glob
import os.path
import sys
from itertools import compress

# copy all parameters (for readability)
# CODE_BASE             = config["CODE_BASE"]
# CODE_BASE             = "/home/NFS/users/l.pagie/usr/local/lib/snakemake/code"
CODE_BASE               = "/home/NFS/users/l.pagie/projects/LP140430_SureSeq_JvArensbergen/analyses/LP161128_Sure_pipeline_snakemake/code"

SAMTOOLS                = "/home/NFS/users/l.pagie/vanSteensel/bin/samtools"
PY2                     = "/home/NFS/users/l.pagie/usr/local/src/miniconda2/envs/wasp/bin/python2.7"
# WASP_DIR                = "/home/NFS/users/l.pagie/usr/local/src/miniconda2/envs/wasp/src/WASP/"
WASP_DIR                = os.path.join(CODE_BASE, "WASP/mapping")
SNP_DIR                 = "/home/NFS/users/l.pagie/projects/LP140430_SureSeq_JvArensbergen/data/LP170210_SuRE42-45_1000Genomes/"
SPLITBAM                = "/home/NFS/users/l.pagie/usr/src/bamUtil/bin/bam splitChromosome "

cDNA_script             = os.path.join(CODE_BASE, "cDNA-plDNA-count-BC.bash")
iPCR_trim_script        = os.path.join(CODE_BASE, "iPCR-trim.bash")
iPCR_mapOnly_script     = os.path.join(CODE_BASE, "iPCR-map.bash")
iPCR_bam2bedpe_script   = os.path.join(CODE_BASE, "iPCR-bam2bedpe.bash")
iPCR_single_QA_script   = os.path.join(CODE_BASE, "iPCR-single-QA.bash")
iPCR_merge_script       = os.path.join(CODE_BASE, "iPCR-merge-bedpe-Filter-BC-multi-pos.bash")
split_bedpe_script      = os.path.join(CODE_BASE, "split-bedpe2chr.sh")
merge_all_script        = os.path.join(CODE_BASE, "merge-iPCR-cDNA-plDNA.bash")
VERSIONFILE             = os.path.join(CODE_BASE, "../", "VERSION")

ADPT_SEQ                = config["ADPT_SEQ"]
ADPTR_IPCR_FORW_SEQ     = config["ADPTR_IPCR_FORW_SEQ"]
ADPTR_IPCR_REV_SEQ      = config["ADPTR_IPCR_REV_SEQ"]
BOWTIE2_REFSEQ          = config["BOWTIE2_REFSEQ"]
MAX_INSERT_LENGTH       = config["MAX_INSERT_LENGTH"]
NCORES                  = config["NCORES"]

CHR_ALL                 = ["chr"+str(i) for i in range(1,23)]+['chrX','chrY','chrM']
CHR_TARGET              = config["CHR_TARGET"]
print("CHR_TARGET=")
print(CHR_TARGET)
CHR_AVAIL=list(compress(CHR_ALL, [os.path.isfile(f) for f in expand(os.path.join(config["OUTDIR"], config["iPCR"]["OUTDIR"], "bed-annot", "iPCR-combined-bedpe_{c}_SNPannot.txt.gz"), c=CHR_ALL)]))

# print pipeline VERSION to stdout
with open(VERSIONFILE, 'r') as myfile:
    VERSION=myfile.read().replace('\n', '')
print ("SuRE-seq pipeline version: ", VERSION, "\n\n")

OUTDIR=config["OUTDIR"]
# OUTDIR=os.path.abspath(OUTDIR)

cDNA_SAMPLES=config["cDNA"]["SAMPLES"]
if cDNA_SAMPLES is None:
  cDNA_SAMPLES={}
cDNA_FASTQ_DIR=config["cDNA"]["FASTQ_DIR"]
cDNA_OUTDIR=os.path.join(config["OUTDIR"], config["cDNA"]["OUTDIR"])
cDNA_COUNTS=expand(os.path.join(cDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=cDNA_SAMPLES.keys())

plDNA_SAMPLES=config["plDNA"]["SAMPLES"]
if plDNA_SAMPLES is None:
  plDNA_SAMPLES={}
plDNA_FASTQ_DIR=config["plDNA"]["FASTQ_DIR"]
plDNA_OUTDIR=os.path.join(config["OUTDIR"], config["plDNA"]["OUTDIR"])
plDNA_COUNTS=expand(os.path.join(plDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=plDNA_SAMPLES.keys())

iPCR_SAMPLES=config["iPCR"]["SAMPLES"]
if iPCR_SAMPLES is None:
  iPCR_SAMPLES={}
iPCR_SAMPLE2FILES={sample:[iPCR_SAMPLES[sample]["R1"],iPCR_SAMPLES[sample]["R2"]] for sample in iPCR_SAMPLES.keys()}
iPCR_FASTQ_DIR=config["iPCR"]["FASTQ_DIR"]
iPCR_OUTDIR=os.path.join(OUTDIR, config["iPCR"]["OUTDIR"])
BEDPE_FILES=expand(os.path.join(iPCR_OUTDIR, "{s}", "{s}.bedpe.gz"), s=iPCR_SAMPLES.keys())
iPCR_TARGETS=expand(os.path.join(OUTDIR, "SuRE-counts_{c}.txt.gz"), c=CHR_TARGET+CHR_AVAIL)

print("iPCR_OUTDIR = "+iPCR_OUTDIR)

print("iPCR_TARGETS = ")
print(iPCR_TARGETS)

if "GID" in config:
  GID=config["GID"]
  # SNP_DIR=os.path.join(SNP_DIR, "SNPs_" + GID)
  SNP_DIR=os.path.join(SNP_DIR, "SNPs")
  if not(os.path.exists(SNP_DIR)):
    sys.exit("GID is defined but SNP directory doesn't exist")
else:
  GID = None
  SNP_DIR=""

# print("GID = " + GID)
print("snp_dir = " + SNP_DIR)

# TYPES=["cDNA","plDNA"]

include: os.path.join(CODE_BASE, "bed2coverage/bed2coverage.rule")

ruleorder: iPCR_mapWASP > iPCR_mapOnly
ruleorder: iPCR_merge_WASP > iPCR_merge
rule all:
  input:
#    [os.path.join(OUTDIR, config[d]["OUTDIR"], s, s+"_trimmed_table.txt.gz") for d in TYPES for s in config[d]["SAMPLES"]],
    expand(os.path.join(cDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=cDNA_SAMPLES.keys()),
    expand(os.path.join(plDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=plDNA_SAMPLES.keys()),
#    os.path.join(OUTDIR, "SuRE-counts.txt.gz") if len(iPCR_SAMPLES) > 0 else [],
    iPCR_TARGETS,
     "bed2coverage.done",
#    "QA.done"

rule QA:
  input:
    expand(os.path.join(iPCR_OUTDIR, "{s}", "iPCR_single_QA.{s}.done"), s=iPCR_SAMPLES.keys())
  output:
    temp(touch("QA.done"))

rule cDNA:
  input:
    lambda wildcards: [os.path.join(cDNA_FASTQ_DIR, f) for f in cDNA_SAMPLES[wildcards.s]]
  output:
    os.path.join(cDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz")
  params:
    dir=os.path.join(cDNA_OUTDIR,"{s}"),
    basename="{s}"
  shell:
    cDNA_script + " -l -b '{params.basename}' -o '{params.dir}' -a {ADPT_SEQ} {input}"

rule plDNA:
  input:
    lambda wildcards: [os.path.join(plDNA_FASTQ_DIR, f) for f in plDNA_SAMPLES[wildcards.s]]
  output:
    os.path.join(plDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz")
  params:
    dir=os.path.join(plDNA_OUTDIR,"{s}"),
    basename="{s}"
  shell:
    cDNA_script + " -l -b '{params.basename}' -o '{params.dir}' -a {ADPT_SEQ} {input}"

rule iPCR_trim:
  input:
    lambda wildcards: [os.path.join(iPCR_FASTQ_DIR, f) for f in iPCR_SAMPLE2FILES[wildcards.s]]
  output:
    os.path.join(iPCR_OUTDIR,"{s}","{s}_forw.fastq"), 
    os.path.join(iPCR_OUTDIR,"{s}","{s}_rev.fastq"),
    os.path.join(iPCR_OUTDIR,"{s}","{s}_forw.info")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}"),
    cutmotif=lambda wildcards: iPCR_SAMPLES[wildcards.s]["CUTMOTIF"],
    forwAdaptr=ADPTR_IPCR_FORW_SEQ,
    revAdaptr=ADPTR_IPCR_REV_SEQ,
    basename="{s}"
  shell:
    iPCR_trim_script + " -o '{params.dir}' -l -d '{params.cutmotif}' -b '{params.basename}' -f '{params.forwAdaptr}' -r '{params.revAdaptr}' -c {input}"

rule iPCR_mapOnly:
  input:
    os.path.join(iPCR_OUTDIR,"{s}","{s}_forw.fastq"), 
    os.path.join(iPCR_OUTDIR,"{s}","{s}_rev.fastq") 
  output:
    os.path.join(iPCR_OUTDIR,"{s}","{s}.bam")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}"),
    stats=os.path.join(iPCR_OUTDIR,"{s}","{s}.stats"),
    basename="{s}",
    refseq=BOWTIE2_REFSEQ,
    maxInsert=MAX_INSERT_LENGTH
  threads: 
    NCORES
  priority: 50
  shell:
    iPCR_mapOnly_script + "  -o '{params.dir}' -l -n {threads} -t $PWD/'{params.stats}' -b '{params.basename}' -m '{params.maxInsert}' -s '{params.refseq}' -c {input}"

rule iPCR_WASP_find_SNPs:
  """find intersecting SNPs using WASP script"""
  input:
    bam=os.path.join(iPCR_OUTDIR,"{s}","map1_sort","{s}_{c}.bam"),
    snpdir=SNP_DIR
  output:
    fastq1=os.path.join(iPCR_OUTDIR,"{s}","find_intersecting_snps","{s}_{c}.remap.fq1.gz"),
    fastq2=os.path.join(iPCR_OUTDIR,"{s}","find_intersecting_snps","{s}_{c}.remap.fq2.gz"),
    keep=os.path.join(iPCR_OUTDIR,"{s}","find_intersecting_snps","{s}_{c}.keep.bam"),
    remap=os.path.join(iPCR_OUTDIR,"{s}","find_intersecting_snps","{s}_{c}.to.remap.bam")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}","find_intersecting_snps")
  shell:
    "mkdir -p '{params.dir}' ; "
    "{PY2} {WASP_DIR}/find_intersecting_snps.py "
    "    --is_paired_end "
    "    --is_sorted "
    "    --output_dir '{params.dir}' "
    "    --snp_dir {input.snpdir} "
    "    {input.bam}"

rule iPCR_WASP_filter_remapped_reads:
  """filter reads from second mapping step"""
  input:
    to_remap_bam=os.path.join(iPCR_OUTDIR,"{s}","find_intersecting_snps","{s}_{c}.to.remap.bam"),
    remap_bam=os.path.join(iPCR_OUTDIR,"{s}","map2_sort","{s}_{c}.bam")
  output:
    keep_bam=os.path.join(iPCR_OUTDIR,"{s}","filter_remapped_reads","{s}_{c}.keep.bam")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}","filter_remapped_reads")
  shell:
    "mkdir -p '{params.dir}' ; "
    "{PY2} {WASP_DIR}/filter_remapped_reads.py "
    "  {input.to_remap_bam} {input.remap_bam} {output.keep_bam}"


rule iPCR_WASP_sort_and_index_bam2:
  input:
    os.path.join(iPCR_OUTDIR,"{s}","map2","{s}_{c}.bam")
  output:
    os.path.join(iPCR_OUTDIR,"{s}","map2_sort","{s}_{c}.bam"),
    os.path.join(iPCR_OUTDIR,"{s}","map2_sort","{s}_{c}.bam.bai")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}","map2_sort")
  threads: 
    4
  resources:
    ram=100
  shell:
    "mkdir -p '{params.dir}' ; "
    "{SAMTOOLS} sort -o {output[0]} -@ {threads} -m 20G {input} -T {output[0]} ; "
    "{SAMTOOLS} index {output[0]} ; "
    "sleep 15 ; "
    "touch -c {output} ; "

rule iPCR_WASP_map_bowtie2_paired_end2:
  input:
    os.path.join(iPCR_OUTDIR,"{s}","find_intersecting_snps","{s}_{c}.remap.fq1.gz"),
    os.path.join(iPCR_OUTDIR,"{s}","find_intersecting_snps","{s}_{c}.remap.fq2.gz")
  output:
    os.path.join(iPCR_OUTDIR,"{s}","map2","{s}_{c}.bam")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}","map2"),
    stats=os.path.join(iPCR_OUTDIR,"{s}","{s}_{c}.stats"),
    basename="{s}_{c}",
    refseq=BOWTIE2_REFSEQ,
    maxInsert=MAX_INSERT_LENGTH
  threads: 
    5
  priority: 50
  shell:
    iPCR_mapOnly_script + "  -o '{params.dir}' -l -n {threads} -t $PWD/'{params.stats}' -b '{params.basename}' -m '{params.maxInsert}' -s '{params.refseq}' -c {input}"

rule iPCR_WASP_sort_and_index_bam1:
  """sort and index bam generated by first mapping step"""
  input:
    os.path.join(iPCR_OUTDIR,"{s}","map1","{s}.bam")
  output:
    expand(os.path.join(iPCR_OUTDIR,"{{s}}","map1_sort", "{{s}}.bam"),c=CHR_TARGET),
    expand(os.path.join(iPCR_OUTDIR,"{{s}}","map1_sort", "{{s}}.bam.bai"),c=CHR_TARGET),
    expand(os.path.join(iPCR_OUTDIR,"{{s}}","map1_sort", "{{s}}_{c}.bam"),c=CHR_TARGET),
    expand(os.path.join(iPCR_OUTDIR,"{{s}}","map1_sort", "{{s}}_{c}.bam.bai"),c=CHR_TARGET)
#    os.path.join(iPCR_OUTDIR,"{s}","map1_sort","{s}.bam"),
#    os.path.join(iPCR_OUTDIR,"{s}","map1_sort","{s}.bam.bai")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}","map1_sort"),
    noext=os.path.join(iPCR_OUTDIR,"{s}","map1_sort","{s}_")
  threads: 
    4
  resources:
    ram=100
  shell:
    "mkdir -p '{params.dir}' ; "
    "{SAMTOOLS} sort -o {output[0]} -@ {threads} -m 20G {input} -T {output[0]} ; "
    "{SAMTOOLS} index {output[0]} ; "
    "{SPLITBAM} --in {output[0]} --out '{params.noext}'; "
    "for f in '{params.noext}'chr*.bam; do {SAMTOOLS} index $f; done ; "
    "sleep 15 ; "
    "touch -c {output} ; "

rule iPCR_WASP_map_bowtie2_paired_end1:
  input:
    os.path.join(iPCR_OUTDIR,"{s}","{s}_forw.fastq"), 
    os.path.join(iPCR_OUTDIR,"{s}","{s}_rev.fastq") 
  output:
    os.path.join(iPCR_OUTDIR,"{s}","map1","{s}.bam")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}","map1"),
    stats=os.path.join(iPCR_OUTDIR,"{s}","{s}.stats"),
    basename="{s}",
    refseq=BOWTIE2_REFSEQ,
    maxInsert=MAX_INSERT_LENGTH
  threads: 
    NCORES
  priority: 50
  shell:
    iPCR_mapOnly_script + "  -o '{params.dir}' -l -n {threads} -t $PWD/'{params.stats}' -b '{params.basename}' -m '{params.maxInsert}' -s '{params.refseq}' -c {input}"

rule iPCR_WASP_merge_bams:
  """merge 'keep' BAM files from mapping steps 1 and 2, then sort and index"""
  input:
    keep1=os.path.join(iPCR_OUTDIR,"{s}","find_intersecting_snps","{s}_{c}.keep.bam"),
    keep2=os.path.join(iPCR_OUTDIR,"{s}","filter_remapped_reads","{s}_{c}.keep.bam")
  output:
    merge=os.path.join(iPCR_OUTDIR,"{s}","merge","{s}_{c}.keep.merge.bam"),
    sort=os.path.join(iPCR_OUTDIR,"{s}","merge","{s}_{c}.keep.merge.sort.bam")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}","merge")
  threads: 
    4
  resources:
    ram=100
  shell:
    "mkdir -p '{params.dir}' ; "
    "{SAMTOOLS} merge {output.merge} {input.keep1} {input.keep2}; "
    "{SAMTOOLS} sort -o {output.sort} -@ {threads} -m 20G {output.merge} -T {output.sort} ; "
    "{SAMTOOLS} index {output.sort}"

rule iPCR_mapWASP:
  input:
    os.path.join(iPCR_OUTDIR,"{s}","merge","{s}_{c}.keep.merge.sort.bam")
  output:
    rmdup=os.path.join(iPCR_OUTDIR,"{s}","rmdup","{s}_{c}.keep.merge.rmdup.bam"),
    sort=os.path.join(iPCR_OUTDIR,"{s}","rmdup","{s}_{c}.keep.merge.rmdup.sort.bam"),
    bamfinal=os.path.join(iPCR_OUTDIR,"{s}","{s}_{c}.bam")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}","rmdup")
  threads: 
    4
  resources:
    ram=100
  priority: 50
  shell:
    "mkdir -p '{params.dir}' ; "
    "{PY2} {WASP_DIR}/rmdup_pe.py {input} {output.rmdup} ;"
    "{SAMTOOLS} sort -n -o {output.sort} -@ {threads} -m 20G  {output.rmdup} -T {output.sort}; "
    #"{SAMTOOLS} index {output.sort} ;"
    "ln -fs $PWD/{output.sort} {output.bamfinal}"

rule iPCR_bam2bedpe:
  input:
    os.path.join(iPCR_OUTDIR,"{s}","{s}_{c}.bam"),
    os.path.join(iPCR_OUTDIR,"{s}","{s}_forw.info")
  output:
    os.path.join(iPCR_OUTDIR, "{s}", "{s}_{c}.bedpe.gz")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}"),
    basename="{s}"
  shell:
    iPCR_bam2bedpe_script + " -o '{params.dir}' -l -b '{params.basename}' {input}" 

rule iPCR_merge:
  input:
     BEDPE_FILES
  output:
    os.path.join(iPCR_OUTDIR, "iPCR-combined-bedpe.txt.gz")
  shell:
    iPCR_merge_script + " -l -o {iPCR_OUTDIR} {input}"

rule iPCR_preMerge_WASP:
  input:
    expand(os.path.join(iPCR_OUTDIR, "{s}", "{s}_{{c}}.bedpe.gz"), s=iPCR_SAMPLES.keys())
  output:
    os.path.join(iPCR_OUTDIR, "bed-annot", "iPCR-combined-bedpe_{c}.txt.gz")
  params:
    dir=os.path.join(iPCR_OUTDIR, "bed-annot")
  shell:
    iPCR_merge_script + " -l -o '{params.dir}' -b {output} {input}"

# rule iPCR_splitSort_WASP:
#   input:
#     os.path.join(iPCR_OUTDIR, "bed-annot", "iPCR-combined-bedpe.txt.gz")
#   output:
#     expand(os.path.join(iPCR_OUTDIR, "bed-annot", "iPCR-combined-bedpe_{c}.txt.gz"),c=CHR_TARGET)
#   shell:
#     split_bedpe_script + " '{input}'"
# 
rule iPCR_annot_WASP:
  input:
    bedpe=os.path.join(iPCR_OUTDIR, "bed-annot", "iPCR-combined-bedpe_{c}.txt.gz"),
    snpdir=SNP_DIR
  output:
    os.path.join(iPCR_OUTDIR, "bed-annot", "iPCR-combined-bedpe_{c}_SNPannot.txt.gz")
  resources:
    ram=25
  shell:
    "{PY2} {WASP_DIR}/annotate_bedpe_LP170516.py --snp_dir {input.snpdir} {input.bedpe} | sort -k6 -S 20G | gzip -c > {output}"

rule iPCR_merge_WASP:
  input:
    expand(os.path.join(iPCR_OUTDIR, "bed-annot", "iPCR-combined-bedpe_{c}_SNPannot.txt.gz"), c= CHR_TARGET)
  output:
    os.path.join(iPCR_OUTDIR, "iPCR-combined-bedpe.txt.gz")
  shell:
    "zcat {input} | gzip -c > {output}"
    # iPCR_merge_script + " -l -o {iPCR_OUTDIR} {input}"

rule merge_all:
  input:
    # iPCR=os.path.join(iPCR_OUTDIR, "iPCR-combined-bedpe.txt.gz"),
    iPCR=os.path.join(iPCR_OUTDIR, "bed-annot", "iPCR-combined-bedpe_{c}_SNPannot.txt.gz"),
    cDNA=expand(os.path.join(cDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=cDNA_SAMPLES.keys()),
    plDNA=expand(os.path.join(plDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=plDNA_SAMPLES.keys())
  output:
    os.path.join(OUTDIR, "SuRE-counts_{c}.txt.gz")
  shell:
    merge_all_script + " -l -i {input.iPCR} -o {OUTDIR} -d {output} {input.cDNA} {input.plDNA}"

rule iPCR_single_QA:
  input:
    os.path.join(iPCR_OUTDIR, "{s}", "{s}.bedpe.gz")
  output:
    touch(os.path.join(iPCR_OUTDIR, "{s}", "iPCR_single_QA.{s}.done"))
  params:
    basename="{s}",
    outdir=os.path.join(iPCR_OUTDIR,"{s}")
  shell:
    iPCR_single_QA_script + " -l -b '{params.basename}' -o '{params.outdir}'"

#rule iPCR_single_QA:
#  input:
#    expand(os.path.join(iPCR_OUTDIR, "{s}", "iPCR_single_QA.{s}.done"), s=iPCR_SAMPLES.keys())
#  output:
#    temp(touch(os.path.join(iPCR_OUTDIR, "{s}", "iPCR_single_QA.done")))

rule all_cDNA:
  input:
    expand(os.path.join(cDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=cDNA_SAMPLES.keys())

rule all_plDNA:
  input:
    expand(os.path.join(plDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=plDNA_SAMPLES.keys())

rule all_iPCR_map:
  input:
    expand(os.path.join(iPCR_OUTDIR, "{s}", "{s}.bedpe.gz"), s=iPCR_SAMPLES.keys())

rule all_iPCR_merge:
  input:
    os.path.join(iPCR_OUTDIR, "iPCR-combined-bedpe.txt.gz")

rule clean:
  input:
    "cDNA_cleaned", "plDNA_cleaned", "iPCR_cleaned"

rule clean_cDNA:
  input:
    expand(os.path.join(cDNA_OUTDIR, "{s}", "{s}_info.gz"), s=cDNA_SAMPLES.keys())
  output:
    temp(touch("cDNA_cleaned"))
  shell:
    "rm -f {input}"

rule clean_plDNA:
  input:
    expand(os.path.join(plDNA_OUTDIR, "{s}", "{s}_info.gz"), s=plDNA_SAMPLES.keys())
  output:
    temp(touch("plDNA_cleaned"))
  shell:
    "rm -f {input}"



rule clean_iPCR_map:
  input:
    expand("{s}_iPCR_cleaned", s=iPCR_SAMPLES.keys())

rule clean_iPCR_map_2nd:
  input:
     os.path.join(iPCR_OUTDIR, "{s}", "{s}.bedpe.gz")
  params:
    dir=os.path.join(iPCR_OUTDIR, "{s}")
  output:
    temp(touch("{s}_iPCR_cleaned"))
  shell:
    "rm -f '{params.dir}'/*tmp.gz '{params.dir}'/*bam '{params.dir}'/*info* '{params.dir}'/*fastq*"


